Что такое generic?
    Механизм параметризированных типов.
    Позволяет объявлять классы и методы, где тип данных указан в виде параметра. 
    Т.е. можно использовать один код с разными входами наподобие формальных параметров в объявлениях методов. 
    Переменная типа может быть любым не примитивным типом.  

    Сделаны для предохранения программиста от путаницы в типах данных.

    Ограничения
        аргументы примитивных типов
        нельзя получить инстансы обобщ типов
        нельзя построить массиы обоб типов
        употреблять в статическом контексте
        нельзя генерировать или перехватывать

    Обобщенный класс - класс с одним или большим числом параметров
        public class Entry<K,V>{}
    Обобщенный метод имеет параметры типа
        public static <T> void swap (T[] array){}

    Parametrized type       List<String>
    Actual type parametr    String
    Generic types           List<E>
    Formal type param       E
    Unbounded Wildcards     List<?>
    Raw type                List
    Bounded type            List<E exntends Number>
    Recursice types bound   <T extends Comparable<T>>
    Bounded wildcard type   List<? extends Number>


Что такое wild cards? 
    символы подстановки, обозначается как ?
    Могут используются только в сигнатуре методов, но не для параметризации класса
    Может быть использован в сочитании ключевыми словами extends и/или super
    (неограниченные) Unbounded Wildcards - <?>
    (огранич свеху) Upper Bounded Wildcards - <? extends Number>
    (огранич cнизу) Lower Bounded Wildcards - <? super Integer> 



Что такое bound wild cards?
    ограниченные символы подстановки
    ограничение сверху - ? extends (все подтипы класса Т)
    ограничение сниху - ? super T (все супертипы класса Т )

    Неочевидные дженерики


Что такое unbounded wild cards?
    неограниченные символы подстановки
    можно применять когда выполняются весьма обобщенные операции
    Подстановочный знак означает «какой-то неизвестный тип».


Где хранится информация про Generics?
    в исходном коде до момента компиляции

PECS

    Используется для выбора типа wildcards:
        extends - когда надо только получать данные из объекта. Метод передает данные в аргумент.
        super - когда надо надо только вставлять данные в объект. Метод читает данные из аргумента


    Для выбора типа используют принцип (мнемонику) PECS (Producer Extends Consumer Super)

    extends - когда надо только получать данные из объекта. Метод передает данные в аргумент.
    super - когда надо надо только вставлять данные в объект. Метод читает данные из аргумента.

    не использовать wildcard, когда требуется и получать и вставлять данные в структуру.

    если метод не записывает данные в аргумент, то данные не могут быть испорчены (? extends)

     public static <T> void copy(List<? super T> dest, List<? extends T> src)

    массивы ковариантны
    дженерики инвариантны


Как можно получить тип Generics?
    через механизм рефлексии
    Существует только одна ситуация, когда универсальный тип доступен во время выполнения - это когда универсальный тип является частью сигнатуры класса подобным образом:
    public class FloatList extends ArrayList<Float> {}
    теперь мы можем узнать что класс ArrayList (а, соответственно, и класс FloatList) был параметризован классом Float следующим образом:

    public static void main(String[] args) {
        ArrayList<Float> listOfNumbers = new FloatList();
        
        Class actual = listOfNumbers.getClass();
        ParameterizedType type = (ParameterizedType) actual.getGenericSuperclass();
        System.out.println(type);
        Class parameter = (Class) type.getActualTypeArguments()[0];
        System.out.println(parameter);
    }

    обобщенный тип компилируется в базовый тип
    если на параметр типа накладываются ограничения, тип заменяется первым ограничением
        

Что такое итератор?

    сущность, позволяющий описать логика прохода по элементам коллекции

    Интерфейс итератор – частная реализация одноименного паттерна, применяемая как к готовым структурам, так и к прочим, на усмотрение программиста.
    Расширяя интерфейс Iterator, ты реализуешь паттерн, но для реализации паттерна не обязательно расширять интерфейс. 

    интерфейс Collection, реализующий интерфейс Iterator. 

    Iterator - это интерфейс, который содержит 3 метода:
    hasNext() - проверяет, есть ли следующий элемент;
    next() - возвращает следующий элемент;
    remove() - удаляет текущий элемент

    В стандартной библиотеке java существует 2 интерфейса это Iterable и Iterator.
    Iterable - нужно релизовать метод возвращающий итератор.
    Iterator - вернуть объект итератора (который хранит состояние)

    Iterable - это тот, который предоставляет Iterator о себе
    Iterator-это простой способ позволить некоторым перебирать коллекцию данных без привилегий назначения (хотя и с возможностью удаления).


Что такое коллекции?
    класс для хранения набора других элементов
    ИЛИ 
    хранилище объектов с динамическим размером, и разным временем на операции: поиск, вставка, удаление.


Назовите базовые интерфейсы коллекций?


            Сollection              Map
                |
        ----------------
        |       |       |
       Set     List     Queue

    На вершине стоит базоый интерфейс Collection (предоставляет методы для работы с простыми наборами элементов и это default-методы)
    Map не расшитяет интерфейс Collection, нр входит в состав Collection API и представляет методы для работы с парами "Ключ-значение"

    List (список) 
    Set (множество уникальных значений) 
    Queue (Однсторння очередь)


Расскажите реализации интерфейса List?

               List I             
                |
        --------------------
        |       |           |
    Vector   ArrayList     LinkedList
        |
    Stack


    ArrayList - список на основе динамич массива (рекомендуется если нужно частое обращение по индексам)
    LinkedList - двусвязный список. Хранится ссылка на следующий и предыдущий объекты коллекции. Можно исползовать как стек или очередь
    Vector - список на основе динамич.массива. Не рекомендуется, если не требуется потокобезопасность
    Stack - реализация стека ЛИФО. После добавления Deque рекомендуется исползовать реализации Deque например ArrayDeque
        

Расскажите реализации интерфейса Set?
                      Set   <------------------  SortedSet I
                       |                                |
            -----------|                         NavigableSet I
            |          |                                |
        HashSet      TreeSet ---------------------->>---
            |
    LinkedHashSet


    Основной особенностью является то, что множества не содержат дубликаты

    HashSet
    вместо интексов применяет некоторые хэш-значение. Данные хранятся в хэш-таблице.
    HashSet - основан на HashMap. 
    В качестве объекта используется добавляемый элемент, в качестве значения - объект пустышка 

    TreeSet
    данные хранит в деревоводной структуре в отсортированном виде.
    Предоставляет возможность управлять порядком элементов в коллекции при помощи объекта Comparator, либо сохраняет элементы с использованием "natural ordering".

    LinkedHashSet - расширяет HashSet, позволяет получать элементы в порядке их добавления


Расскажите реализации интерфейса Map?

                                Map I
                                |
        ---------------------------------------------------------
        |               |               |                       |
    WeakHashMap     Hashmap        SortedMap I              HashTable
                                        |
                                    NavigableMap I
                                        |
                                    TreeMap

    HashTable - синхрониз; нельзя использовать null как ключ или значение
    HashMap - не синхронизированная хэш-таблица; можно использовать null как ключ или значение. Добавление за О(1), получение и удаление зависит от хэш-функции
    WeakHashMap - c использованием слабых ссылок                               
    LinkedHashMap - упорядоченная хэш-таблица с порядком итерирования в порядке добавления (за счет большего исползования памяти)
    TreeMap - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратов в конструкторе.


Отличие ArrayList от LinkedList?

    ArrayList - список на основе массива, который умеет динамически расширяться
        + быстрота доступа по индексу
        + расходы на хранение
        + вставка в конец (в среднем) за константное время
        - при insert\remove в середину происходит свдиг элементов (медленно)
        - медленно доступ по значению
        ==  по умолчанию n = 10 (размер)

    LinkedList - список на основе связного списка, который хранит ссылка на элементы до и после
        + add\remove первого и последнего - О(1)
        + insert (но линейное время на поиск)
        - поиск по индексу и значению О(н) за линейное время (кроме первого и последнего)

    LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или когда необходимо гарантированное время добавления элемента в список.



Отличие Set от List?
    Set - множество, не хранит дубликаты.
    List - список, может содержать дубли.
    В List может находится сколько угодно null, а в Set максимум - один. 
    Set быстрее. 
    Например, реализация HeshSet решает проблемы ArrayList и LinkedList в части скорости доступа и операций с элементами.


Расскажите про методы Object hashCode и equals?
    Методы, необходимые для сравнения объектов.
    equals - метод, который реализует класс для сравнения своих экземпляров по значимым полям (определить логическую эквивалентность объектов)
    hashcode - для увеличения производительности при сравнении. Хэш возвращает для любого объекта 32битный int

    Правила hashCode
        Переопределять hashCode() надо каждый раз, если переопределен equals().
        Общие требования такие:
        1. Равные объекты должны давать одинаковые хэшкоды (при условии что никакое из значимых полей не изменилось. Значимые поля - те, которые использованы в методе equals())
        2. Для логически равных объектов hashCode() должен возвращать одинаковые значения
        3. Если объекты логически не равно, то hashCode() может возвратить одинаковые значения (нужно стараться минимизировать такие случаи).
        Дополнительно:
        1. Из вычисления хэшкода можно исключить производные поля (которые вычисляются из других).
        2. Нужно исключить все поля, которые не используются в метода equals().

    Техника вычисления hashCode
        Для всех значимых полей нужно:
        1. вычислить хэшкод значения поля
        2. объединить значение с предыдущим через: хэшкод = 31 * хэшкод + вычисленное значение


    Правила equals
        Когда не нужно переопределять
        1. Когда каждый инстанс уникальный (Thread, Enum)
        2. Когда не потребуется определять уникальность (Random)
        3. Когда класс который вы расширяете уже имеет свою реализиацю (Например, для классов Set, List, Map реализация equals находится в AbstractSet, AbstractList и AbstractMap соответственно)
        4. когда класс приватный и вы уверен что equals никогда не будет вызван

        При переопределении нужно придерживаться правил:
        1. рефлексивность
            x.equals(x) = true
            если нарушить: не сможем найти объект, если положили его в коллекцию
        2. симметричность
            x.equals(y) = true => y.equals(x)
        3. транзитивность
            x.equals(y) = true && y.equals(z) = true => x.equals(z) = true
        4. согласованность \ непротиворечивость
            x.equals(y) = true (всегда, при любом повторе)
        5. сравнение с null
            x.equals(null) = false

        Общий принцип переопределения:
        1. if (this == o) return true;
        2. if (o == null || getClass() != o.getClass()) return false;
        3. User user = (User) o;
        4. сравнить все значимые поля:
            -- примитивные типы через =
            -- ссылочные поля через equals()
            -- массивы либо в цикле либо Array.equals()
            -- float \ double через методы оберточных классов *.compare()

    !!! ДОПИСАТЬ ЧТО БУДЕТ ЕСЛИ НЕ ПЕРЕОПРЕДЕЛЯТЬ

Расскажите про реализации Map?
    HashMap - основан на хэш-таблицах. Ключи и значения могут быть любых типов, в том числе и null. 
    Данная реализация не дает гарантий относительно порядка элементов.
    Класс HashMap наследуется от класса AbstractMap и реализует следующие интерфейсы: Map, Cloneable, Serializable.

    LinkedHashMap - расширяет класс HashMap. Он создает связный список элементов в карте, расположенных в том порядке, в котором они вставлялись.

    TreeMap - Он создает коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном порядке по возрастанию. Время доступа и извлечения элементов достаточно мало, что делает класс TreeMap отличным выбором для хранения больших объемов отсортированной информации
    Может использовать компаратов в конструкторе.



Детали про Hashmap
    Как происходит добавление в HashMap:
    1. вычисляется хэш введенного ключа (из объекта)
        ПЛЮС
        static final int hash(Object key) {
            int h;
            return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
        }
    2. Вычисляем индекс бакета (ячейки массива), в который будет добавлен наш элемент:
    3. Создается объект Node
    4.Теперь, зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. 
    Если в бакете пусто, тогда просто размещаем в нем элемент.
    Иначе хэш и ключ нового элемента поочередно сравниваются с хешами и ключами элементов из списка и, при совпадении этих параметров, значение элемента перезаписывается. 
    Если совпадений не найдено, элемент добавляется в конец списка.

    КАК ВЫЧИСЛЯЕТСЯ ХЭШ В HASHMAP
    хэш в HashMap вычисляется как хэшкод^(хэшкод >>> 16) -- здесь битовый сдвиг вправо можно представить как целочисленное деление: хэшкод / Math.pow(2, n)

    XOR здесь используется для побитового перемешивания, чтобы лучше распределить значения по корзинам (иначе получается, что на индекс корзины влияют только младшие биты хэша).

    Побитовый сдвиг вправо с заполнением нулями
    Если обычный сдвиг битов вправо сохраняет знак числа (старший бит сохраняет свое значение), в случае со сдвигом вправо с заполнением нулями этого не происходит. А происходит заполнение старшего бита нулем.


    ЗАЧЕМ НУЖЕН БИТОВЫЙ СДВИГ
    Это сделано из-за того, что hashCode() можно реализовать так, что только нижние биты int'a будут заполнены. Например, для Integer, Float – если мы в HashMap кладем маленькие значения, то у них и биты хеш-кодов будут заполнены только нижние. В таком случае ключи в HashMap будут иметь тенденцию скапливаться в нижних ячейках, а верхние будут оставаться пустыми, что не очень эффективно. На то, в какой бакет попадёт новая запись, влияют только младшие биты хеша. Поэтому и придумали различными манипуляциями подмешивать старшие биты хеша в младшие, чтобы улучшить распределение по бакетам (чтобы старшие биты родного хеша объекта начали вносить коррективы в то, в какой бакет попадёт объект) и, как следствие, производительность. Потому и придумана дополнительная функция hash внутри HashMap.


    ЗАЧЕМ СРАНИВИТЬ ХЭШ ПРИ ПОИСКЕ В КОРЗИНЕ (ответ: Сравнение осуществляется в таком порядке во благо производительности)
    В первую очередь мы сравниваем добавляемый элемент с первым элементом связного списка внутри бакета:
    (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
    При проверке сначала сравниваются хеши ключей. 
    Если этот «участок» (p.hash == hash) возвращает false, тогда остальная часть условия игнорируется (&&), так как объекты гарантированно разные.
    Иначе затем сравниваются ключи по ссылке (==) и в случае неравенства, ключи сравниваются уже посредством метода equals(). Сравнение осуществляется в таком порядке во благо производительности. 
    Если все три выражения возвращают true, это означает, что ключи равны и новый элемент будет записан в дополнительную переменную, чтобы в дальнейшем с её помощью перезаписать значение у ключа.


    float loadFactor — этот параметр отвечает за то, при какой степени загруженности текущей хеш-таблицы необходимо создавать новую хеш-таблицу, т.е. как только хеш-таблица заполнилась на 75%, будет создана новая хеш-таблица с перемещением в неё текущих элементов (затратная операция, так как требуется перехеширование всех элементов);
    int threshold — предельное количество элементов, при достижении которого размер хэш-таблицы увеличивается вдвое. Рассчитывается по формуле (capacity * loadFactor);
    static final int DEFAULT_INITIAL_CAPACITY= 1 << 4 — емкость хеш-таблицы по умолчанию (16);
    static final int MAXIMUM_CAPACITY = 1 << 30 — максимально возможная емкость хеш-таблицы (приблизительно 1 млрд.);
    static final float DEFAULT_LOAD_FACTOR = 0.75f — коэффициент загрузки, используемый по умолчанию;
    static final int TREEIFY_THRESHOLD = 8 — это «порог» количества элементов в одной корзине, при достижении которого внутренний связный список будет преобразован в древовидную структуру (красно-черное дерево).
    static final int UNTREEIFY_THRESHOLD = 6 — если количество элементов в одной корзине уменьшится до 6, то произойдет обратный переход от дерева к связному списку;
    static final int MIN_TREEIFY_CAPACITY = 64 — минимальная емкость (количество корзин) хеш-таблицы, при которой возможен переход к древовидной структуре. Т.е. если в хеш-таблице по крайней мере 64 бакета и в одном бакете 8 или более элементов, то произойдет переход к древовидной структуре.



Расскажите, что такое коллизии в Map? Как с ними бороться?
    Коллизия - это ситуация, когда разные объекты имеют одинаковые хеш-коды, т.е такие объекты должны попасть в одну корзину. Возникает проблема - как хранить эти объекты в одной корзине.
    Возникает оттого, что количество значений хеш-функций меньше (ограничены диапазоном значений типа int 2^32), чем вариантов исходных данных. Вероятность возникновения коллизий оценивает качество хеш-функций.

    Есть два подхода для разрешения это ситуации:
    1) метод цепочек - несколько объектов в одной корзине хранятся в виде связного списка.
    2) метод открытой адресации, когда объекты при обнаружении коллизии добавляются в первую пустую ячейку справа (реализовано, например, в IdentityHashMap)
 
    Какая структура данных помимо списка используется для разрешения коллизий начиная с java 1.8?
    Сбалансированное дерево.
    После достижения определенного порога вместо связанных списков используются сбалансированные деревья. В Hashmap начале сохраняет объекты в связанном списке, но после того, как колличество элементов в хэше достигает определенного порога, происходит переход к дереву.


Расскажите, что такое анализ алгоритма?

    АА позволяюет понять как влияет количество элементов на число операций.
    Анализ алгоритма позволяет выбрать оптимальную структуру данных для определенной задачи.

    Под АА понимается анализ времени, которое потребуется для обработки очень большого набора.
    Сколько времени нужно на обработку масссива из 10 шт? 1000? Милиона?
    Если алгоритм обрабатывает 1000 шт за 5мс, что будет если мы передадим туда 1млн?
    Будет он выполнятся 5 мин или 5 лет?

    Порядок роста описывает то, как сложность алгоритма растет с увеличением размера входных данных. 


    O(1) – константная сложность;
    О(n) – линейная сложность (цикл)
    О(Log(n)) – логарифмическая сложность (поиск в бинарном дереве)
    O(n!) – факториальная сложност (например рекурсивная сложность)
    О(n^2) - пузырьковая сортировка


Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? . С чем связаны отличия?
    ArrayList: индекс - 0(1), поиск 0(n). вставка 0(n), удаление O(n).
    LinkedList: индекс - 0(n), поиск 0(n). вставка 0(1), удаление O(1).
    Деревья для всех операций - O(log(n)). 
    Хэш таблицы - O(1) для всех операций, если не считать коллизии
    


Расскажите реализации данных очередей и стеков.
        Queue I
          |
        Deque I
          |
         ----------
        |          |
    LinkedList    ArrayDeque


    Базовым интерфейсом всех очередей Java является Queue.
    Этот интерфейс описывает коллекции FIFO (first-in-first-out). 
    Добавление элементов в очередь -
     методом add(), 
     удаление - poll(), 
     получение первого элемента без его удаления - peek().
    Две самые простые реализации очереди - это LinkedList и PriorityQueue. 

    Deque - это сокращение от «double ended queue» (двусторонняя очередь).   
    Интерфейс Deque позиционируется как современная альтернатива классу Stack.
    Технически Deque является расширением интерфейса очереди Queue.
    Интерфейс Deque реализуют всё тот же LinkedList, а также ArrayDeque.


    PriorityQueue — является единственной прямой реализацией интерфейса Queue (была добавлена, как и интерфейс Queue, в Java 1.5), не считая класса LinkedList, который так же реализует этот интерфейс, но был реализован намного раньше. Особенностью данной очереди является возможность управления порядком элементов. По-умолчанию, элементы сортируются с использованием «natural ordering», но это поведение может быть переопределено при помощи объекта Comparator, который задаётся при создании очереди.

    В Java есть одноимённый класс Stack. Добавление элементов осуществляется методом push(), а удаление методом pop().

    ArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами, позволяющими реализовать конструкцию вида LIFO (last-in-first-out)
        peekFirst() — возвращает (но не удаляет из очереди) первый элемент.
        peekLast() — возвращает (но не удаляет из очереди) последний элемент.
        pollFirst() — возвращает первый элемент из очереди и удаляет его.
        pollLast() — возвращает последний элемент из очереди и удаляет его.
        addFirst() — добавляет новый элемент в начало очереди.
        addLast() — добавляет элемент в конец очереди.
    

    Queue (одностороняя очередь) - когда элементы можно получить в том порядке в котором добавляли. FIFO
    Dequeue (двусторонняя очередь) - можно вставлять/получать элементы из начали и конца.
    Stack - можно получить только последний элемент LIFO  


Расскажите про реализации деревьев.
    - бинарность, это когда у узла не более двух потомков
    - поисковость, это как раз соблюдение условия left <= parrent, right >= parrent

    TreeMap - упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратор в конструкторе. Красно-черные дерево - это самобалансирующееся дерево, которое гарантирует логарифмический рост высоты дерева от числа узлов.

    TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию хеш-кодов. Можно управлять порядком при помощи компаратора.



Что такое loadFactor?
    Это коэффициент загруженности, при превышении которого происходит автоматическое изменение размера коллекции HashSet или карты Map. Обычно он выставляется равным 0,75 или 75%. Может назодится в пределах от 0 до 1.