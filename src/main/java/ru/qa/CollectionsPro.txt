1. Что такое generic?

    Обобщения - это параметризованные типы. 
    С их помощью можно объявлять классы, интерфейсы и методы, где тип данных указан в виде параметра. 
    Дженерики позволяют типам (классам и интерфейсам) быть параметрами при определении классов, интерфейсов и методов.
    Параметры типа предоставляют возможность повторно использовать один и тот же код с разными входами наподобие формальных параметров в объявлениях методов. Разница в том, что входные данные для формальных параметров являются значениями, а для дженериков - типами данных. Переменная типа может быть любым не примитивным типом.

    Сделаны для предохранения программиста от путаницы в типах данных.
     После компиляции какая-либо информация о дженериках стирается. Это называется "Стирание типов"

2. Что такое wild cards? 
    используются в сигнатуре методов, но для параметризации класса - нет!

3. Что такое bound wild cards?
    Lower Bounded Wildcards <? super T> имеет ограничение снизу. Все супертипы класса Т 
    Upper Bounded Wildcards <? extends T> имеет ограничение сверху. Все классы, унаследованные от класса T

4. Что такое unbounded wild cards?
    Unbounded Wildcards <?>


5. Где хранится информация про Generics?
    во время компиляции происходит так называемое стирание типов. Это значит, что во время выполнения программы недоступна информация о типе-параметре. Существует только одна ситуация, в которой можно получить тип во время выполнения программы - когда универсальный тип является частью сигнатуры класса.

6. Как можно получить тип Generics?
    https://habr.com/ru/post/66593/


    Для выбора типа используют принцип PECS (Producer Extends Consumer Super)
    extends - когда надо только получать данные из объекта. Метод передает данные в аргумент.
    super - когда надо надо только вставлять данные в объект. Метод читает данные из аргумента.
    не использовать wildcard, когда требуется и получать и вставлять данные в структуру.


7. Что такое итератор?

    это поведенческий шаблон проектирования, который позволяет пройтись по всем элементам некоторого составного объекта. Одним из важных условий при реализации паттерная является то, что итератор должен гарантировать нераскрытие внутреннего устройства объекта.

    Iterator - это интерфейс, который содержит 3 метода:
    hasNext() - проверяет, есть ли следующий элемент;
    next() - возвращает следующий элемент;
    remove() - удаляет текущий элемент. Объект итератора позволяет выполнить перемещение по последовательности объектов с выбором каждого объекта этой последовательности.

8. Что такое коллекции?
    класс для хранения набора других элементов

9. Назовите базовые интерфейсы коллекций?
    List:: ArrayList, LinkedList
    Set:: HashSet, LinkedHashSet, TreeSet
    Map:: HashMap, LinkedHashMap, TreeMap

10. Расскажите реализации интерфейса List?
    List:: ArrayList, LinkedList
    ArrayList - на массиве с несинхронизированными методами.
    Vector - на массиве с синхронизированными методами.
    Stack - на массиве есть синхронизированные методы но не все.
    LinkedList - двусвязный список.

11. Расскажите реализации интерфейса Set?
    HashSet - основан на HashMap.
    LinkedHashSet - расширяет HashSet, позволяет получать элементы в порядке их добавления, но требует больше памяти.
    TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию hashCode()'ов. Можно управлять порядком при помощи компаратора.

12. Расскажите реализации интерфейса Map?
    HashMap - не синхронизированная хэш-таблица (быстрая).
    LinkedHashMap - упорядоченная хэш-таблица с порядком итерирования в порядке добавления.
    TreeMap - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратов в конструкторе.

13. Отличие ArrayList от LinkedList?
    Позволяет хранить любые значения в том числе и null
    AL
    ++ быстро
        get, доступ по индексу О(1)
    -- медленно
        доступ по значению за О(н)
        insert\remove (нужно сдвигать все значения)

    LL:
    ++ быстро:
        add\remove первого и последнего - О(1)
        insert (но линейное время на поиск)
    -- медленно
        поиск по индексу и значению О(н)

    ArrayList - список на основе массива, который умеет динамически расширяться
        + быстрота доступа по индексу
        + расходы на хранение
        + вставка в конец (в среднем) за константное время
        - при вставке в середину происходит свдиг элементов
        ==  по умолчанию n = 10 (размер)

    LinkedList - список на основе связного списка, который хранит ссылка на элементы до и после
        + вставка и удаление на конст время
        - доступ за линейное время (кроме первого и последнего)

        LinkedList предпочтительно применять, когда происходит активная работа (вставка/удаление) с серединой списка или когда необходимо гарантированное время добавления элемента в список.


14. Отличие Set от List?
    Set - множество уникальных объектов
    в List могут харниться дублекаты, в Set - нет. List - упорядоченная коллекция, а Set - нет. В List может находится сколько угодно null, а в Set максимум - один. Set быстрее. Например, реализация HeshSet решает проблемы ArrayList и LinkedList в части скорости доступа и операций с элементами.
    Set - множество, не хранит дубликаты.
    List - список, может содержать дубли.


15. Расскажите про методы Object hashCode и equals?
    Методы, необходимые для сравнения объектов.
    equals - метод, который реализует класс для сравнения своих экземпляров по значимым полям
    hashcode - для увеличения производительности при сравнении. Хэш возвращает для любого объекта 32битный int


16. Расскажите про реализации Map?
    Map:: HashMap, LinkedHashMap, TreeMap
    У интерфейса Map из Java Collections Framework есть несколько реализаций, и у некоторых из них есть очень интересные свойства, знание которых поможет Вам эффективно решать определенные задачи. Отличия между двумя распространенными реализациями - HashMap и TreeMap - такие же, как между HashSet и TreeSet (тем более, что последние реализованы на основе первых). Так же есть еще интересные реализации - LinkedHashMap, EnumMap, WeakHashMap.

    С LinkedHashMap все просто - получаете преимущества поика по хэш коду и, в дополнение к этому, порядок элементов при итерации будет таким же, как при вставке. С помощью конструкторов этого класса можно задать некоторые параметры, которые будут влиять на скорость работы, объем занимаемой памяти, а также на порядок элементов при итерации. Последнее особенно интересно, так как позволяет использовать LinkedHashMap в очень интересных решениях, одно из которых - простейший LRU-кэш.

    С EnumMap все еще проще - обычный Map, где ключами есть значения enum. Не все это знают, но эффективность хранения элементов и скорость работы намного превышает другие реализации, при использовании перечислений для ключей.

    Реализация WeakHashMap основана на использовании слабых ссылок (WeakReference) для ключей. Это позволяет эффективно использовать Map для временного хранения информации, где запись будет удалятся, когда сборщик мусора в Java удалит объект ключа. Для продуктивного и правильного использования этой реализации необходимо понимание механизма ссылок в Java и работы сборщика мусора.

    HashMap - основан на хэш-таблицах. Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не дает гарантий относительно порядка элементов

    LinkedHashMap - расширяет класс HashMap. Он создает связный список элементов в карте, расположенных в том порядке, в котором они вставлялись.

    TreeMap - Он создает коллекцию, которая для хранения элементов применяет дерево. Объекты сохраняются в отсортированном порядке по возрастанию. Время доступа и извлечения элементов достаточно мало, что делает класс TreeMap отличным выбором для хранения больших объемов отсортированной информации

17. Расскажите, что такое коллизии в Map? Как с ними бороться?
    Коллизия - это ситуация, когда не эквивалентные элементы имеют одинаковые хеш-коды. Возникает оттого, что количество значений хеш-функций меньше (ограничены диапазоном значений типа int 2^32), чем вариантов исходных данных. Вероятность возникновения коллизий оценивает качество хеш-функций.
    Коллизия - это когда для двух объектов вычисляется одинаковый хеш-код.
    Решение: проверить методом equals(), что ссылки на объекты не равны. Для хэш-таблицы в ту же ячейку добавляется еще один объект, за счет того что каждая ячейка - это связанный список.

    В Java для разрешения коллизий используется модифицированный метод цепочек. Суть: когда количество элементов в корзине превышает определенное значение, данная корзина переходит от использования связного списка к использованию сбалансированного дерева. Но данный метод имеет смысл лишь тогда, когда на элементах хеш-таблицы задан линейный порядок. Т.е. при использовании данных типа int или double имеет смысл переходить к дереву поиска, а при использовании каких-нибудь ссылок на объекты не имеет, т.к. они не реализуют нужный интерфейс. Такой подход позволяет улучшить производительность с O(n) до O(log(n)). Данный способ используется в таких коллекциях как HashMap, LinkedHashMap и ConcurrentHashMap.

18. Расскажите, что такое анализ алгоритма?

    O(1) – константная сложность;
    О(n) – линейная сложность;
    О(nа) – полиномиальная сложность;
    О(Log(n)) – логарифмическая сложность;
    O(n*log(n)) – квазилинейная сложность;
    O(2^n) – экспоненциальная сложность;
    O(n!) – факториальная сложность.

19. Какая временная сложность алгоритмов(O-нотация) добавления, замены и удаления в каждой из коллекций? . С чем связаны отличия?
    https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/pro_2.png
    
    
20. Расскажите реализации данных очередей и стеков.
21. Расскажите про реализации деревьев.
22. Что такое loadFactor?


1. Общее про коллекции и не только:
    а) Java 8, Полное руководство - Герберт Шилдт. Глава 18 (стр. 563)
    б) Библиотека профессионала. Java. Том 1. Основы - Кей Хостманн, Гари Корнелл. Глава 13 (стр. 683)
    в) Head First Java - Кэти Сьерра и Берт Бейтс. Глава 16 (стр. 559)
    г) Философия Java - Брюс Эккель. Глава 11 (стр. 323)
    д) Effective Java - Joshua Bloch.
    е) Грокаем Алгоритмы - Адитья Бхаргава.
    ж) Алгоритмы и структуры данных - Николаус Вирт 
    з) Структуры данных и алгоритмы Java. Роберт Лафоре
 
2. Обобщения:
   а) Java 8, Полное руководство - Герберт Шилдт. Глава 14 (стр. 395)
   б) Библиотека профессионала. Java. Том 1. Основы - Кей Хостманн, Гари Корнелл. Глава 12. (стр. 645)
   в) Head First Java - Кэти Сьерра и Берт Бейтс. Глава 16 (стр. 570)
   г) Философия Java - Брюс Эккель. Глава 15 (стр. 501)
 
3. Сортировка:            
    а) Java 8, Полное руководство - Герберт Шилдт. Глава 18 (стр. 614 - 622)
    б) Библиотека профессионала. Java. Том 1. Основы - Кей Хостманн, Гари Корнелл. Глава 13 (стр. 739)
    в) Head First Java - Кэти Сьерра и Берт Бейтс. Глава 16 (стр. 564)
 
4. Создание собственных коллекций:
 а) Структуры данных и алгоритмы Java. Роберт Лафоре;
    - Глава 4. Стеки и Очереди (стр. 121)
    - Глава 5. Связанные списки (стр. 180)
    - Глава 8 (стр. 346), 9 (стр. 403), 10 (стр. 436). Деревья
    - Глава 11. Хеш-таблицы (стр. 487)  

5. equals, hashCode, toString:
                                           
                  а) Effective Java - Joshua Bloch. Глава 3 (стр. 46) 